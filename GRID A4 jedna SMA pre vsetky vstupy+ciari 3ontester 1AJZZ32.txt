//+------------------------------------------------------------------+
//|                Grid-SMA EA  (v2.12 ñ LONG & SHORT)               |
//|                © Open-source                                     |
//+------------------------------------------------------------------+
#property copyright "Open source"
#property link      ""
#property version   "2.12"
#property strict

#include <Trade\Trade.mqh>
CTrade m_trade;

//------------------------------------------------------------------
//| Flag: beûÌme v genetickej optimaliz·cii?                         |
//------------------------------------------------------------------
bool optimizationMode = false;   // nastavÌ sa v OnInit()

//------------------------------------------------------------------
//|                         ?? Inputs ??                             |
//------------------------------------------------------------------+

//---? 1a. GRID & STRAT…GIA ñ LONG
input group "1a Grid parametre a SMA logika ñ LONG"
input bool   enableLongGrid            =  true; // zapn˙ù/vypn˙ù LONG vetvu
input double distance                  = 629;   // min. vzdialenosù medzi vstupmi (body)
input double takeProfit                = 155;   // TP (body) od priemernej ceny
input double initialLotSize            = 0.1;   // prv· pozÌcia ñ lot
input double lotSizeMultiplier         = 1.83;  // n·sobok Ôalöieho lotu
input int    fastSMA_period            = 1;     // r˝chle SMA
input int    slowSMA_period            = 75;    // pomalÈ SMA
input ENUM_TIMEFRAMES smaTimeframe     = PERIOD_M1; // timeframe pre LONG SMA

//---? 1b. GRID & STRAT…GIA ñ SHORT
input group "1b Grid parametre a SMA logika ñ SHORT"
input bool   enableShortGrid           =  true; // zapn˙ù/vypn˙ù SHORT vetvu
input double distanceShort             = 629;   // min. vzdialenosù (body) pre short
input double takeProfitShort           = 155;   // TP (body) pod priemerom
input double initialLotSizeShort       = 0.1;   // prv· short pozÌcia ñ lot
input double lotSizeMultiplierShort    = 1.83;  // n·sobok Ôalöieho lotu
input int    fastSMA_periodShort       = 1;     // r˝chle SMA pre short
input int    slowSMA_periodShort       = 75;    // pomalÈ SMA pre short
input ENUM_TIMEFRAMES smaTimeframeShort = PERIOD_M1; // timeframe pre SHORT SMA

//---? 2. OBCHODN… HODINY
input group "2 ObchodnÈ hodiny"
input int StartHour   = 3;
input int StartMinute = 0;
input int EndHour     = 22;
input int EndMinute   = 0;
input int maxGrids    = 8;                  // max. poËet vstupov v gride

//---? 3. RIZIKO & MONEY MANAGEMENT
input group "3 Money Management"
input bool   useEquityStopLoss       = false;
input double equityStopLossThreshold = -1000;  // Ä
input int    magicNumber             = 123456; // spoloËn˝ magic

//---? 4. CHOVANIE EA
input group "4 Spr·vanie experta"
input bool closePositionsOnCandleClose     = true;
input bool useSameCandleBlock              = true;
input bool useDistanceBeforeSMACross       = true;
input bool showObjects                     = true;
input bool skipFirstCandleAfterGap         = true;
input int  skipGapMinutes                  = 60;
input bool useCandleCloseForDistanceAndTP  = true;

//---? 5. NOTIFIK¡CIE
input group "5 Notifik·cie"
input bool enableZoneNotifications         = false;
input bool enableOpenPositionNotifications = false;
input bool enableCloseNotifications        = false;

//------------------------------------------------------------------
//|                     Glob·lne premennÈ ñ LONG                    |
//------------------------------------------------------------------
bool      gridCycleRunning      = false;
double    lastPositionLotSize   = 0.0;
double    lastPositionPrice     = 0.0;
double    priceLevelsSummation  = 0.0;
double    totalLotSizeSummation = 0.0;
datetime  lastCandleTime        = 0;
int       currentGridCount      = 0;

int       handleFastSMA;
int       handleSlowSMA;

datetime  lastCloseCandle   = 0;
bool      belowDistanceReached = false;
double    lastBid            = 0.0;
bool      tpNotificationSent = false;

//------------------------------------------------------------------
//|                 Glob·lne premennÈ ñ SHORT                       |
//------------------------------------------------------------------
bool      gridCycleRunningShort      = false;
double    lastPositionLotSizeShort   = 0.0;
double    lastPositionPriceShort     = 0.0;
double    priceLevelsSummationShort  = 0.0;
double    totalLotSizeSummationShort = 0.0;
datetime  lastCandleTimeShort        = 0;
int       currentGridCountShort      = 0;

int       handleFastSMAShort;
int       handleSlowSMAShort;

datetime  lastCloseCandleShort = 0;
bool      aboveDistanceReached = false;
double    lastAsk              = 0.0;
bool      tpNotificationSentShort = false;

//------------------------------------------------------------------
//| Makro LOG ñ potl·Ëa Print poËas optimaliz·cie                   |
//------------------------------------------------------------------
#define LOG  if(!optimizationMode) Print

//------------------------------------------------------------------
//|                   PomocnÈ funkcie ñ LONG                        |
//------------------------------------------------------------------
double AveragePrice()        { return totalLotSizeSummation ? priceLevelsSummation/totalLotSizeSummation : 0.0; }
double TPLevel()             { return AveragePrice() + takeProfit*_Point; }
double MinDistanceLevel()    { return lastPositionPrice - distance*_Point; }

//------------------------------------------------------------------
//|                   PomocnÈ funkcie ñ SHORT                       |
//------------------------------------------------------------------
double AveragePriceShort()        { return totalLotSizeSummationShort ? priceLevelsSummationShort/totalLotSizeSummationShort : 0.0; }
double TPLevelShort()             { return AveragePriceShort() - takeProfitShort*_Point; }
double MinDistanceLevelShort()    { return lastPositionPriceShort + distanceShort*_Point; }

//--- n·zvy objektov LONG
#define OBJ_AVG   "AveragePriceLine"
#define OBJ_TP    "TakeProfitLine"
#define OBJ_DIST  "MinDistanceLine"
#define OBJ_BTN   "btnCloseAll"
//--- n·zvy objektov SHORT
#define OBJ_AVG_S   "AveragePriceLineShort"
#define OBJ_TP_S    "TakeProfitLineShort"
#define OBJ_DIST_S  "MinDistanceLineShort"

//------------------------------------------------------------------
//| Odstr·ni LONG grafickÈ objekty                                  |
//------------------------------------------------------------------
void RemoveAllEAObjects()
{
   if(optimizationMode) return;
   const string objs[4] = { OBJ_AVG, OBJ_TP, OBJ_DIST, OBJ_BTN };
   for(int i=0;i<4;i++)
      if(ObjectFind(0, objs[i])!=-1)
         ObjectDelete(0, objs[i]);
}

//------------------------------------------------------------------
//| Odstr·ni SHORT grafickÈ objekty                                 |
//------------------------------------------------------------------
void RemoveShortEAObjects()
{
   if(optimizationMode) return;
   const string objs[3] = { OBJ_AVG_S, OBJ_TP_S, OBJ_DIST_S };
   for(int i=0;i<3;i++)
      if(ObjectFind(0, objs[i])!=-1)
         ObjectDelete(0, objs[i]);
}

//------------------------------------------------------------------
void DrawLine(const string name,const double price,const color clr)
{
   if(optimizationMode || !showObjects)
   {
      if(ObjectFind(0,name)!=-1) ObjectDelete(0,name);
      return;
   }
   if(ObjectFind(0,name)!=-1) ObjectDelete(0,name);

   ObjectCreate(0,name,OBJ_HLINE,0,0,price);
   ObjectSetInteger(0,name,OBJPROP_COLOR,clr);
   ObjectSetInteger(0,name,OBJPROP_RAY_RIGHT,false);
}

//------------------------------------------------------------------
void UpdateVisuals()
{
   if(optimizationMode || !showObjects){ RemoveAllEAObjects(); return; }
   DrawLine(OBJ_AVG,  AveragePrice(),  clrBlue);
   DrawLine(OBJ_TP,   TPLevel(),       clrGreen);
   DrawLine(OBJ_DIST, MinDistanceLevel(), clrYellow);
}

//------------------------------------------------------------------
void UpdateVisualsShort()
{
   if(optimizationMode || !showObjects){ RemoveShortEAObjects(); return; }
   DrawLine(OBJ_AVG_S,  AveragePriceShort(),  clrBlue);
   DrawLine(OBJ_TP_S,   TPLevelShort(),       clrRed);
   DrawLine(OBJ_DIST_S, MinDistanceLevelShort(), clrYellow);
}

//------------------------------------------------------------------
void CreateCloseAllButton()
{
   if(optimizationMode || !showObjects) return;

   if(ObjectFind(0,OBJ_BTN)!=-1) ObjectDelete(0,OBJ_BTN);

   if(!ObjectCreate(0, OBJ_BTN, OBJ_BUTTON, 0, 0, 0))
   { LOG("Failed to create CloseAll button:",GetLastError()); return; }

   ObjectSetString (0, OBJ_BTN, OBJPROP_TEXT, "Close All");
   ObjectSetInteger(0, OBJ_BTN, OBJPROP_XDISTANCE, 10);
   ObjectSetInteger(0, OBJ_BTN, OBJPROP_YDISTANCE, 50);
   ObjectSetInteger(0, OBJ_BTN, OBJPROP_CORNER,   CORNER_LEFT_UPPER);
   ObjectSetString (0, OBJ_BTN, OBJPROP_FONT,     "Arial");
   ObjectSetInteger(0, OBJ_BTN, OBJPROP_FONTSIZE, 10);
   ObjectSetInteger(0, OBJ_BTN, OBJPROP_COLOR,    clrWhite);
   ObjectSetInteger(0, OBJ_BTN, OBJPROP_BGCOLOR,  clrBlue);
}

//------------------------------------------------------------------
bool IsWithinTradingHours()
{
   MqlDateTime t; TimeToStruct(TimeCurrent(),t);
   int nowMin   = t.hour*60 + t.min;
   int startMin = StartHour*60 + StartMinute;
   int endMin   = EndHour  *60 + EndMinute;

   if(startMin < endMin)
      return (nowMin>=startMin && nowMin<endMin);
   if(startMin > endMin) // cez polnoc
      return (nowMin>=startMin || nowMin<endMin);
   return true;
}

//------------------------------------------------------------------
bool IsBarBullish(const int shift)
{
   return iClose(_Symbol,smaTimeframe,shift) > iOpen(_Symbol,smaTimeframe,shift);
}
bool IsBarBearish(const int shift)
{
   return iClose(_Symbol,smaTimeframeShort,shift) < iOpen(_Symbol,smaTimeframeShort,shift);
}

//------------------------------------------------------------------
//|               LONG ñ naËÌtanie uû beûiaceho gridu               |
//------------------------------------------------------------------
void LoadGridCycleState()
{
   totalLotSizeSummation=0; priceLevelsSummation=0; currentGridCount=0;
   bool found=false; double minPrice=0, lotAtMin=0;

   for(int i=0;i<PositionsTotal();i++)
   {
      ulong tk=PositionGetTicket(i); if(!PositionSelectByTicket(tk)) continue;
      if(PositionGetString(POSITION_SYMBOL)!=_Symbol ||
         PositionGetInteger(POSITION_MAGIC)!=magicNumber ||
         PositionGetInteger(POSITION_TYPE)!=POSITION_TYPE_BUY) continue;

      double lot=PositionGetDouble(POSITION_VOLUME);
      double op =PositionGetDouble(POSITION_PRICE_OPEN);
      totalLotSizeSummation+=lot;
      priceLevelsSummation +=lot*op;
      currentGridCount++;

      if(!found || op<minPrice){ minPrice=op; lotAtMin=lot; found=true; }
   }

   gridCycleRunning = found;
   lastPositionPrice= minPrice;
   lastPositionLotSize=lotAtMin;

   if(gridCycleRunning && enableLongGrid) UpdateVisuals();
   else RemoveAllEAObjects();
}

//------------------------------------------------------------------
//|               SHORT ñ naËÌtanie uû beûiaceho gridu              |
//------------------------------------------------------------------
void LoadGridCycleStateShort()
{
   totalLotSizeSummationShort=0; priceLevelsSummationShort=0; currentGridCountShort=0;
   bool found=false; double maxPrice=0, lotAtMax=0;

   for(int i=0;i<PositionsTotal();i++)
   {
      ulong tk=PositionGetTicket(i); if(!PositionSelectByTicket(tk)) continue;
      if(PositionGetString(POSITION_SYMBOL)!=_Symbol ||
         PositionGetInteger(POSITION_MAGIC)!=magicNumber ||
         PositionGetInteger(POSITION_TYPE)!=POSITION_TYPE_SELL) continue;

      double lot=PositionGetDouble(POSITION_VOLUME);
      double op =PositionGetDouble(POSITION_PRICE_OPEN);
      totalLotSizeSummationShort+=lot;
      priceLevelsSummationShort +=lot*op;
      currentGridCountShort++;

      if(!found || op>maxPrice){ maxPrice=op; lotAtMax=lot; found=true; }
   }

   gridCycleRunningShort = found;
   lastPositionPriceShort= maxPrice;
   lastPositionLotSizeShort=lotAtMax;

   if(gridCycleRunningShort && enableShortGrid) UpdateVisualsShort();
   else RemoveShortEAObjects();
}

//------------------------------------------------------------------
void CheckGridCycleValidity()
{
   int myPos=0;
   for(int i=0;i<PositionsTotal();i++)
   {
      ulong tk=PositionGetTicket(i); if(!PositionSelectByTicket(tk)) continue;
      if(PositionGetString(POSITION_SYMBOL)==_Symbol &&
         PositionGetInteger(POSITION_MAGIC)==magicNumber &&
         PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY) myPos++;
   }

   if(gridCycleRunning && myPos==0)
   {
      gridCycleRunning=false;
      lastPositionPrice=lastPositionLotSize=0;
      totalLotSizeSummation=priceLevelsSummation=0;
      currentGridCount=0; belowDistanceReached=false; tpNotificationSent=false;

      if(useSameCandleBlock) lastCloseCandle=iTime(_Symbol,smaTimeframe,0);

      RemoveAllEAObjects(); CreateCloseAllButton();
      if(enableCloseNotifications && !optimizationMode)
         SendNotification(StringFormat("EA INFO: Vöetky LONG pozÌcie na %s boli manu·lne zatvorenÈ.",_Symbol));
      LOG("Manual closure ñ long grid reset.");
   }
}

//------------------------------------------------------------------
void CheckGridCycleValidityShort()
{
   int myPos=0;
   for(int i=0;i<PositionsTotal();i++)
   {
      ulong tk=PositionGetTicket(i); if(!PositionSelectByTicket(tk)) continue;
      if(PositionGetString(POSITION_SYMBOL)==_Symbol &&
         PositionGetInteger(POSITION_MAGIC)==magicNumber &&
         PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL) myPos++;
   }

   if(gridCycleRunningShort && myPos==0)
   {
      gridCycleRunningShort=false;
      lastPositionPriceShort=lastPositionLotSizeShort=0;
      priceLevelsSummationShort=totalLotSizeSummationShort=0;
      currentGridCountShort=0; aboveDistanceReached=false; tpNotificationSentShort=false;

      if(useSameCandleBlock) lastCloseCandleShort=iTime(_Symbol,smaTimeframeShort,0);

      RemoveShortEAObjects();
      if(enableCloseNotifications && !optimizationMode)
         SendNotification(StringFormat("EA INFO: Vöetky SHORT pozÌcie na %s boli manu·lne zatvorenÈ.",_Symbol));
      LOG("Manual closure ñ short grid reset.");
   }
}

//------------------------------------------------------------------
void CheckEquityStopLoss()
{
   if(!useEquityStopLoss) return;
   double floating=0;
   for(int i=0;i<PositionsTotal();i++)
   {
      ulong tk=PositionGetTicket(i); if(!PositionSelectByTicket(tk)) continue;
      if(PositionGetString(POSITION_SYMBOL)==_Symbol &&
         PositionGetInteger(POSITION_MAGIC)==magicNumber)
         floating+=PositionGetDouble(POSITION_PROFIT);
   }
   if(floating<=equityStopLossThreshold){ LOG("Equity SL hit:",floating); CloseAllPositions(); }
}

//------------------------------------------------------------------
bool CheckSMACrossover()
{
   double f[2],s[2];
   if(CopyBuffer(handleFastSMA,0,1,2,f)<2){LOG("Fast SMA err",GetLastError());return false;}
   if(CopyBuffer(handleSlowSMA,0,1,2,s)<2){LOG("Slow SMA err",GetLastError());return false;}
   bool up=(f[1]<s[1])&&(f[0]>s[0]);
   bool dn=(f[1]>s[1])&&(f[0]<s[0]);
   if(up||dn) LOG("SMA crossover:", up?"Up":"Down");
   return (up||dn);
}

bool CheckSMACrossoverShort()
{
   double f[2],s[2];
   if(CopyBuffer(handleFastSMAShort,0,1,2,f)<2){LOG("Fast SMA short err",GetLastError());return false;}
   if(CopyBuffer(handleSlowSMAShort,0,1,2,s)<2){LOG("Slow SMA short err",GetLastError());return false;}
   bool up=(f[1]<s[1])&&(f[0]>s[0]);
   bool dn=(f[1]>s[1])&&(f[0]<s[0]);
   if(up||dn) LOG("SMA crossover (short):", dn?"Down":"Up");
   return (up||dn);
}

//------------------------------------------------------------------
void CloseAllPositions()
{
   for(int i=PositionsTotal()-1;i>=0;i--)
   {
      ulong tk=PositionGetTicket(i); if(!PositionSelectByTicket(tk))continue;
      if(PositionGetString(POSITION_SYMBOL)==_Symbol &&
         PositionGetInteger(POSITION_MAGIC)==magicNumber)
         m_trade.PositionClose(tk);
   }
   StopGridCycle();
   StopGridCycleShort();
}

//------------------------------------------------------------------
void OnChartEvent(const int id,const long &l,const double &d,const string &s)
{
   if(optimizationMode) return;
   if(id==CHARTEVENT_OBJECT_CLICK && s==OBJ_BTN){ LOG("CloseAll clicked"); CloseAllPositions(); }
}

//------------------------------------------------------------------
//|                       LONG ñ ötart gridu                        |
//------------------------------------------------------------------
void StartGridCycle()
{
   if(!enableLongGrid)       return;
   if(!IsWithinTradingHours()){ LOG("Outside trading hours."); return; }

   double refPrice = useCandleCloseForDistanceAndTP ? iClose(_Symbol,smaTimeframe,1)
                                                    : SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);

   if(!m_trade.Buy(initialLotSize,_Symbol,ask,0,0))
   { LOG("Cannot open first pos:",GetLastError()); return; }

   lastPositionLotSize=initialLotSize;
   lastPositionPrice  =refPrice;
   priceLevelsSummation = initialLotSize*refPrice;
   totalLotSizeSummation = initialLotSize;
   currentGridCount=1; gridCycleRunning=true;
   belowDistanceReached=false; tpNotificationSent=false;
   lastBid=SymbolInfoDouble(_Symbol,SYMBOL_BID);

   if(enableOpenPositionNotifications && !optimizationMode)
      SendNotification(StringFormat("EA INFO: Otvoren· 1. LONG pozÌcia %.2f lot @%.5f",initialLotSize,ask));

   UpdateVisuals(); CreateCloseAllButton();
   LOG("Long grid started.");
}

//------------------------------------------------------------------
//|                       SHORT ñ ötart gridu                       |
//------------------------------------------------------------------
void StartGridCycleShort()
{
   if(!enableShortGrid) return;
   if(!IsWithinTradingHours()){ LOG("Outside trading hours."); return; }

   double refPrice = useCandleCloseForDistanceAndTP ? iClose(_Symbol,smaTimeframeShort,1)
                                                    : SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);

   if(!m_trade.Sell(initialLotSizeShort,_Symbol,bid,0,0))
   { LOG("Cannot open first short pos:",GetLastError()); return; }

   lastPositionLotSizeShort=initialLotSizeShort;
   lastPositionPriceShort  =refPrice;
   priceLevelsSummationShort = initialLotSizeShort*refPrice;
   totalLotSizeSummationShort = initialLotSizeShort;
   currentGridCountShort=1; gridCycleRunningShort=true;
   aboveDistanceReached=false; tpNotificationSentShort=false;
   lastAsk=SymbolInfoDouble(_Symbol,SYMBOL_ASK);

   if(enableOpenPositionNotifications && !optimizationMode)
      SendNotification(StringFormat("EA INFO: Otvoren· 1. SHORT pozÌcia %.2f lot @%.5f",initialLotSizeShort,bid));

   UpdateVisualsShort();
   LOG("Short grid started.");
}

//------------------------------------------------------------------
//|            LONG ñ otvorenie Ôalöej pozÌcie v gride              |
//------------------------------------------------------------------
void OpenNextPosition(const ENUM_ORDER_TYPE type,const double trigPrice)
{
   if(!enableLongGrid) return;
   if(!IsWithinTradingHours()){ LOG("Outside trading hours."); return; }

   double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   if(ask>MinDistanceLevel()){ LOG("Price above min distance."); return; }

   double refPrice = useCandleCloseForDistanceAndTP ? iClose(_Symbol,smaTimeframe,1) : ask;
   double lot = NormalizeDouble(lastPositionLotSize*lotSizeMultiplier,2);

   if(!m_trade.Buy(lot,_Symbol,ask,0,0)){ LOG("Cannot open next pos:",GetLastError()); return; }

   lastPositionLotSize=lot;
   lastPositionPrice  =refPrice;
   priceLevelsSummation+=lot*refPrice;
   totalLotSizeSummation+=lot;
   currentGridCount++;
   tpNotificationSent=false;
   lastBid=SymbolInfoDouble(_Symbol,SYMBOL_BID);

   if(enableOpenPositionNotifications && !optimizationMode)
      SendNotification(StringFormat("EA INFO: Otvoren· Ôalöia LONG pozÌcia %.2f lot @%.5f",lot,ask));

   UpdateVisuals();
   LOG("Opened next LONG position.");
}

//------------------------------------------------------------------
//|            SHORT ñ otvorenie Ôalöej pozÌcie v gride             |
//------------------------------------------------------------------
void OpenNextPositionShort(const double trigPrice)
{
   if(!enableShortGrid) return;
   if(!IsWithinTradingHours()){ LOG("Outside trading hours."); return; }

   double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);
   if(bid<MinDistanceLevelShort()){ LOG("Price below min distance (short)."); return; }

   double refPrice = useCandleCloseForDistanceAndTP ? iClose(_Symbol,smaTimeframeShort,1) : bid;
   double lot = NormalizeDouble(lastPositionLotSizeShort*lotSizeMultiplierShort,2);

   if(!m_trade.Sell(lot,_Symbol,bid,0,0)){ LOG("Cannot open next short pos:",GetLastError()); return; }

   lastPositionLotSizeShort=lot;
   lastPositionPriceShort  =refPrice;
   priceLevelsSummationShort+=lot*refPrice;
   totalLotSizeSummationShort+=lot;
   currentGridCountShort++;
   tpNotificationSentShort=false;
   lastAsk=SymbolInfoDouble(_Symbol,SYMBOL_ASK);

   if(enableOpenPositionNotifications && !optimizationMode)
      SendNotification(StringFormat("EA INFO: Otvoren· Ôalöia SHORT pozÌcia %.2f lot @%.5f",lot,bid));

   UpdateVisualsShort();
   LOG("Opened next SHORT position.");
}

//------------------------------------------------------------------
void StopGridCycle()
{
   gridCycleRunning=false;

   for(int i=PositionsTotal()-1;i>=0;i--)
   {
      ulong tk=PositionGetTicket(i); if(!PositionSelectByTicket(tk))continue;
      if(PositionGetString(POSITION_SYMBOL)==_Symbol &&
         PositionGetInteger(POSITION_MAGIC)==magicNumber &&
         PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)
         m_trade.PositionClose(tk);
   }

   currentGridCount=0; lastPositionPrice=lastPositionLotSize=0;
   totalLotSizeSummation=priceLevelsSummation=0;
   belowDistanceReached=false; tpNotificationSent=false; lastBid=0;

   if(useSameCandleBlock) lastCloseCandle=iTime(_Symbol,smaTimeframe,0);

   RemoveAllEAObjects(); CreateCloseAllButton();
   if(enableCloseNotifications && !optimizationMode)
      SendNotification(StringFormat("EA INFO: Vöetky LONG pozÌcie na %s boli zatvorenÈ EA.",_Symbol));

   LOG("Long grid ended.");
}

//------------------------------------------------------------------
void StopGridCycleShort()
{
   gridCycleRunningShort=false;

   for(int i=PositionsTotal()-1;i>=0;i--)
   {
      ulong tk=PositionGetTicket(i); if(!PositionSelectByTicket(tk))continue;
      if(PositionGetString(POSITION_SYMBOL)==_Symbol &&
         PositionGetInteger(POSITION_MAGIC)==magicNumber &&
         PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)
         m_trade.PositionClose(tk);
   }

   currentGridCountShort=0; lastPositionPriceShort=lastPositionLotSizeShort=0;
   priceLevelsSummationShort=totalLotSizeSummationShort=0;
   aboveDistanceReached=false; tpNotificationSentShort=false; lastAsk=0;

   if(useSameCandleBlock) lastCloseCandleShort=iTime(_Symbol,smaTimeframeShort,0);

   RemoveShortEAObjects();
   if(enableCloseNotifications && !optimizationMode)
      SendNotification(StringFormat("EA INFO: Vöetky SHORT pozÌcie na %s boli zatvorenÈ EA.",_Symbol));

   LOG("Short grid ended.");
}

//------------------------------------------------------------------
int OnInit()
{
   // detekcia optimaliz·cie
   optimizationMode = (bool)MQLInfoInteger(MQL_OPTIMIZATION);
   m_trade.SetExpertMagicNumber(magicNumber);

   if(fastSMA_period>=slowSMA_period){ LOG("Fast SMA musÌ byù < Slow SMA"); return INIT_FAILED; }
   if(fastSMA_periodShort>=slowSMA_periodShort){ LOG("Fast SMA (short) musÌ byù < Slow SMA (short)"); return INIT_FAILED; }

   handleFastSMA      = iMA(_Symbol,smaTimeframe,      fastSMA_period,      0,MODE_SMA,PRICE_CLOSE);
   handleSlowSMA      = iMA(_Symbol,smaTimeframe,      slowSMA_period,      0,MODE_SMA,PRICE_CLOSE);
   handleFastSMAShort = iMA(_Symbol,smaTimeframeShort, fastSMA_periodShort, 0,MODE_SMA,PRICE_CLOSE);
   handleSlowSMAShort = iMA(_Symbol,smaTimeframeShort, slowSMA_periodShort, 0,MODE_SMA,PRICE_CLOSE);

   if(handleFastSMA==INVALID_HANDLE || handleSlowSMA==INVALID_HANDLE ||
      handleFastSMAShort==INVALID_HANDLE || handleSlowSMAShort==INVALID_HANDLE)
   { LOG("SMA handle error"); return INIT_FAILED; }

   lastCandleTime      = iTime(_Symbol,smaTimeframe,1);
   lastCandleTimeShort = iTime(_Symbol,smaTimeframeShort,1);

   LoadGridCycleState();
   LoadGridCycleStateShort();

   if(!enableLongGrid)  RemoveAllEAObjects();
   if(!enableShortGrid) RemoveShortEAObjects();

   CreateCloseAllButton();
   LOG(optimizationMode ? "EA initialized (optimization mode)." : "EA initialized.");
   return(INIT_SUCCEEDED);
}

//------------------------------------------------------------------
void OnTick()
{
   double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);

   CheckEquityStopLoss();
   CheckGridCycleValidity();
   CheckGridCycleValidityShort();

   //----------------------------------------------------------------
   // LONG logika (pouûÌva enableLongGrid)
   //----------------------------------------------------------------
   if(enableLongGrid)
   {
      if(gridCycleRunning && !closePositionsOnCandleClose && ask>=TPLevel())
         StopGridCycle();

      datetime candle=iTime(_Symbol,smaTimeframe,0);
      if(candle!=lastCandleTime)
      {
         int gap=int((candle-lastCandleTime)/60); lastCandleTime=candle;

         if(skipFirstCandleAfterGap && gap>=skipGapMinutes){ LOG("Gap skip LONG"); }
         else
         {
            if(gridCycleRunning)
            {
               UpdateVisuals();
               if(closePositionsOnCandleClose && ask>=TPLevel()) StopGridCycle();
            }

            if(!gridCycleRunning)
            {
               if(!(useSameCandleBlock && candle==lastCloseCandle) && CheckSMACrossover())
                  StartGridCycle();
            }
            else
            {
               if(useDistanceBeforeSMACross)
               {
                  if(ask<=MinDistanceLevel()) belowDistanceReached=true;

                  if(belowDistanceReached &&
                     !(useSameCandleBlock && candle==lastCloseCandle) &&
                     CheckSMACrossover() &&
                     currentGridCount<maxGrids &&
                     (currentGridCount<1 || IsBarBullish(1)))
                  {
                     OpenNextPosition(ORDER_TYPE_BUY,ask);
                     belowDistanceReached=false;
                  }
               }
               else if(ask<=MinDistanceLevel() &&
                       !(useSameCandleBlock && candle==lastCloseCandle) &&
                       CheckSMACrossover() &&
                       currentGridCount<maxGrids)
                  OpenNextPosition(ORDER_TYPE_BUY,ask);
            }
         }
      }
   }

   //----------------------------------------------------------------
   // SHORT logika (pouûÌva enableShortGrid)
   //----------------------------------------------------------------
   if(enableShortGrid)
   {
      if(gridCycleRunningShort && !closePositionsOnCandleClose && bid<=TPLevelShort())
         StopGridCycleShort();

      datetime candleShort=iTime(_Symbol,smaTimeframeShort,0);
      if(candleShort!=lastCandleTimeShort)
      {
         int gapS=int((candleShort-lastCandleTimeShort)/60); lastCandleTimeShort=candleShort;

         if(skipFirstCandleAfterGap && gapS>=skipGapMinutes){ LOG("Gap skip SHORT"); }
         else
         {
            if(gridCycleRunningShort)
            {
               UpdateVisualsShort();
               if(closePositionsOnCandleClose && bid<=TPLevelShort()) StopGridCycleShort();
            }

            if(!gridCycleRunningShort)
            {
               if(!(useSameCandleBlock && candleShort==lastCloseCandleShort) && CheckSMACrossoverShort())
                  StartGridCycleShort();
            }
            else
            {
               if(useDistanceBeforeSMACross)
               {
                  if(bid>=MinDistanceLevelShort()) aboveDistanceReached=true;

                  if(aboveDistanceReached &&
                     !(useSameCandleBlock && candleShort==lastCloseCandleShort) &&
                     CheckSMACrossoverShort() &&
                     currentGridCountShort<maxGrids &&
                     (currentGridCountShort<1 || IsBarBearish(1)))
                  {
                     OpenNextPositionShort(bid);
                     aboveDistanceReached=false;
                  }
               }
               else if(bid>=MinDistanceLevelShort() &&
                       !(useSameCandleBlock && candleShort==lastCloseCandleShort) &&
                       CheckSMACrossoverShort() &&
                       currentGridCountShort<maxGrids)
                  OpenNextPositionShort(bid);
            }
         }
      }
   }

   //----------------------------------------------------------------
   // Vizualiz·cie & notifik·cie (tick)
   //----------------------------------------------------------------
   if(enableLongGrid && gridCycleRunning && !optimizationMode && showObjects)
      DrawLine(OBJ_DIST,MinDistanceLevel(),clrYellow);

   if(enableShortGrid && gridCycleRunningShort && !optimizationMode && showObjects)
      DrawLine(OBJ_DIST_S,MinDistanceLevelShort(),clrYellow);

   if(enableZoneNotifications && !optimizationMode)
   {
      // LONG
      if(enableLongGrid && gridCycleRunning && totalLotSizeSummation>0)
      {
         if(!tpNotificationSent && lastBid<TPLevel() && bid>=TPLevel())
         {
            SendNotification(StringFormat("EA INFO: %s pretÌna LONG TP %.5f zdola nahor.",_Symbol,TPLevel()));
            tpNotificationSent=true;
         }
         lastBid=bid;
      }
      // SHORT
      if(enableShortGrid && gridCycleRunningShort && totalLotSizeSummationShort>0)
      {
         if(!tpNotificationSentShort && lastAsk>TPLevelShort() && ask<=TPLevelShort())
         {
            SendNotification(StringFormat("EA INFO: %s pretÌna SHORT TP %.5f zhora nadol.",_Symbol,TPLevelShort()));
            tpNotificationSentShort=true;
         }
         lastAsk=ask;
      }
   }
}

//------------------------------------------------------------------
double OnTester()
{
   double profit=TesterStatistics(STAT_PROFIT);
   double dd    =TesterStatistics(STAT_EQUITY_DD);
   if(dd==0) return (profit>0 ? 9999999.0 : -9999999.0);
   return profit/dd;
}
//+------------------------------------------------------------------+